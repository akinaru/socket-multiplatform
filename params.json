{"name":"Socket-multiplatform","tagline":"Multi-platform Socket connection types","body":"# Multi-platform Socket connections\r\n\r\n<i>Last update 19/05/2015</i>\r\n\r\nThis project will features socket connection implementation on multiple platforms and frameworks :\r\n\r\n<table>\r\n    <tr>\r\n        <td colspan=\"6\"></td>\r\n        <td colspan=\"2\"><b>Java</b></td>\r\n        <td colspan=\"2\"><b>Browser</b></td>\r\n        <td colspan=\"2\"><b>C++ QT4</b></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\" rowspan=\"4\">HTTP Server socket</td>\r\n        <td colspan=\"2\" rowspan=\"2\">blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\" rowspan=\"8\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\" rowspan=\"2\">non-blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\" rowspan=\"4\">Server websocket</td>\r\n        <td colspan=\"2\" rowspan=\"2\">blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\" rowspan=\"2\">non-blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"4\" rowspan=\"2\">HTTP Client socket</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\" rowspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"4\" rowspan=\"2\">Client websocket</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n     <tr>\r\n        <td colspan=\"2\" rowspan=\"4\">UDP server</td>\r\n        <td colspan=\"2\" rowspan=\"2\">blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\" rowspan=\"2\">non-blocking</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"4\" rowspan=\"2\">UDP Client</td>\r\n        <td colspan=\"2\">no ssl</td>\r\n        <td colspan=\"2\"><img src=\"./OK.png\"/></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n    <tr>\r\n        <td colspan=\"2\">ssl</td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n        <td colspan=\"2\"></td>\r\n    </tr>\r\n</table>\r\n\r\nList of external projects :\r\n\r\n* Websocket C++ QT4 :  http://akinaru.github.io/websocket-non-blocking-cpp/\r\n\r\n* Websocket JAVA    :  http://akinaru.github.io/websocket-java/\r\n\r\n<hr/>\r\n\r\n<b>How to launch Java HTTP Server socket</b>\r\n\r\n```\r\nHttpServer server = new HttpServer(PORT);\r\n\r\nserver.start();\r\n\r\n```\r\n\r\n<b>How to monitor my clients connected to server ?</b>\r\n\r\nJust add a Listener to server object. You have 1 callback that enables you to :\r\n\r\n* To get current http frame object received (decoded http frame)\r\n\r\n* To get http decoding frame status (in case of parsing error, reading error or socket error)\r\n\r\n* To write Http request or response back to current client\r\n\r\n```\r\nserver.addServerEventListener(new IHttpServerEventListener() {\r\n\r\n            @Override\r\n            public void onHttpFrameReceived(IHttpFrame httpFrame,HttpStates receptionStates, IHttpStream httpStream) {\r\n\r\n                //check if http frame is OK\r\n                if (receptionStates == HttpStates.HTTP_FRAME_OK) {\r\n\r\n                    //you can check here http frame type (response or request frame)\r\n                    if (httpFrame.isHttpRequestFrame()) {\r\n\r\n                        //we want to send a message to client for http GET request on page with uri /index\r\n                        if (httpFrame.getMethod().equals(\"GET\") && httpFrame.getUri().equals(\"/index\")) {\r\n\r\n                            HashMap<String, String> headers = new HashMap<String, String>();\r\n\r\n                            String defaultPage = \"Hello from custom Java HTTP Server\\r\\nThis page has been seen \"\r\n                                    + PAGE_VIEW_COUNT + \" times before.\";\r\n\r\n                            // return default html page for this HTTP Server\r\n                            httpStream.writeHttpResponseFrame(new HttpResponseFrame(\r\n                                            StatusCodeList.OK, new HttpVersion(1, 1), headers, defaultPage.getBytes()));\r\n                            PAGE_VIEW_COUNT++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n```\r\nFeatured exemple display a message in client's browser when uri /index is called. When refreshing page counter will be incremented on displayed page.\r\n\r\n``IHttpFrame`` has following useful methods :\r\n* boolean isHttpRequestFrame() \r\n* boolean isHttpResponseFrame()\r\n* String getMethod()\r\n* String getUri()\r\n* HashMap<String, String> getHeaders()\r\n* int getStatusCode()\r\n* String getReasonPhrase()\r\n* HttpVersion getHttpVersion()\r\n\r\n``HttpStates`` enum can have following states : \r\n* MALFORMED_HTTP_FRAME\r\n* HTTP_FRAME_OK\r\n* HTTP_READING_ERROR\r\n* HTTP_WRONG_VERSION\r\n* HTTP_STATE_NONE\r\n* SOCKET_ERROR\r\n* HTTP_BODY_PARSE_ERROR\r\n\r\n``IHttpStream`` enables you to answered to http client with : \r\n* writeHttpResponseFrame(IHttpResponseFrame httpFrame)\r\n* writeHttpRequestFrame(IHttpFrame httpFrame)\r\n\r\n``IHttpResponseFrame`` and ``IHttpFrame`` are interface issued from http-endec-java project in http://akinaru.github.io/http-endec-java/\r\n\r\n<hr/>\r\n\r\n<b>How to launch a SSL secured HTTP server ?</b>\r\n\r\n```\r\nHttpServer server = new HttpServer(PORT);\r\n\r\nserver.setSsl(true); // set SSL to true (default is false)\r\n\r\n```\r\n\r\nThen you set your keystore, trustore, type of these certificates, filepath and passwords : \r\n\r\n```\r\nserver.setSSLParams(String KEYSTORE_DEFAULT_TYPE,\r\n            String KEYSTORE_FILE_PATH,\r\n            String TRUSTORE_FILE_PATH,\r\n            String SSL_PROTOCOL,\r\n            String KEYSTORE_PASSWORD,\r\n            String TRUSTORE_PASSWORD);\r\n```\r\n\r\nHere is the description of all of these parameters : \r\n\r\n* KEYSTORE_DEFAULT_TYPE : type of certificates used as keystore, it usually contains public and private certificates, common format are PKCS12 and JKS\r\n* TRUSTORE_DEFAULT_TYPE : type of certificates used as trustore, it should contain list of CA cert your server will trust\r\n* KEYSTORE_FILE_PATH : file path to keystore cert file\r\n* TRUSTORE_FILE_PATH: file path to trustore cert file\r\n* SSL_PROTOCOL : ssl protocol used \r\n* KEYSTORE_PASSWORD : keystore file password\r\n* TRUSTORE_PASSWORD : trustore file password\r\n\r\nEventually add event listener as described above and start HTTP server : \r\n\r\n```\r\nserver.start();\r\n```\r\n\r\n<hr/>\r\n\r\n<b> Build/Connect a Java client socket</b>\r\n\r\nBuild an instance of client socket for later connection to server on HOSTNAME:PORT\r\n\r\n``ClientSocket clientSocket = new ClientSocket(HOSTNAME, PORT);```\r\n\r\nAdd a client event listener to be notified when incoming http arrives from the server\r\n\r\n```\r\nclientSocket.addClientSocketEventListener(new IHttpClientListener() {\r\n\r\n            @Override\r\n            public void onIncomingHttpFrame(HttpFrame frame,\r\n                    HttpStates httpStates, IClientSocket clientSocket) {\r\n\r\n                //here test if http frame decoding is fine\r\n                if (httpStates == HttpStates.HTTP_FRAME_OK && frame.isHttpResponseFrame()) {\r\n\r\n                    //manage your response from the server or what you want\r\n\r\n                }\r\n            }\r\n        });\r\n```\r\n\r\nYou can write request to server with ``write(byte[] data)`` method :\r\n\r\n```clientSocket.write(\"GET /say_hello HTTP/1.1\\r\\n\\r\\n\".getBytes(\"UTF-8\"));```\r\n\r\nYou can use http-endec library to build http frame request or response to be sent to the server : http://akinaru.github.io/http-endec-java/\r\n\r\nThe ``write(byte[] data)`` method will automatically connect to the server and send your http frame data direclty. A reading thread will be created on the fly and response from the server will be received there and dispatch to your client event listener, you have declared above.\r\n\r\nDepending on your server implementation, client connection will be closed immediatly after http frame processing from the server. Reading thread will die shortly when no data remains to be read from the server socket.\r\n\r\n<hr/>\r\n\r\n<b> Build/Connect a Java SSL client socket</b>\r\n\r\nThis is the same as above but we add some SSL flavor to this : \r\n\r\nBuild an instance of client socket for later connection to server on HOSTNAME:PORT\r\n\r\n```\r\nClientSocket clientSocket = new ClientSocket(HOSTNAME, PORT);\r\n\r\n//set SSL encryption\r\nclientSocket.setSsl(true);\r\n\r\n```\r\n\r\nThen you set your keystore, trustore, type of these certificates, filepath and passwords : \r\n\r\n```\r\nclientSocket.setSSLParams(KEYSTORE_DEFAULT_TYPE, TRUSTORE_DEFAULT_TYPE,\r\n        KEYSTORE_FILE_PATH, TRUSTORE_FILE_PATH, SSL_PROTOCOL,\r\n        KEYSTORE_PASSWORD, TRUSTORE_PASSWORD);\r\n\r\n```\r\n\r\nHere is the description of all of these parameters : \r\n\r\n* KEYSTORE_DEFAULT_TYPE : type of certificates used as keystore, it usually contains public and private certificates, common format are PKCS12 and JKS\r\n* TRUSTORE_DEFAULT_TYPE : type of certificates used as trustore, it should contain list of CA cert your client will trust\r\n* KEYSTORE_FILE_PATH : file path to keystore cert file\r\n* TRUSTORE_FILE_PATH: file path to trustore cert file\r\n* SSL_PROTOCOL : ssl protocol used \r\n* KEYSTORE_PASSWORD : keystore file password\r\n* TRUSTORE_PASSWORD : trustore file password\r\n\r\nLater, when you will write http frames to your client socket, all your data will be encrypted according to your SSL settings\r\n\r\n\r\n<hr/>\r\n\r\n<b>Java UDP Server/Client</b>\r\n\r\nUDP Server and client are located in udp folder. One exemple features interactions between UDP server and UDP client in JAVA.\r\n\r\nThe following will start an UDP socket (running as server) on port defined by PORT : \r\n\r\n```\r\nUdpServer udpServer = new UdpServer(PORT);\r\n\r\n//add a server event listener\r\nudpServer.addServerEventListener(new IUdpServerEventListener() {\r\n\r\n    @Override\r\n    public void onDataReceived(byte[] data, IUdpServer server,\r\n            InetAddress clientAddress, int clientPort) {\r\n        \r\n        String dataStr = new String(data);\r\n\r\n        System.out\r\n                .println(\"[UDP SERVER] new data receveived in server : \"\r\n                        + dataStr);\r\n    }\r\n});\r\n\r\n// UDP server is runnable : just run it into a thread ( naming the thread is recommended for debuggging )\r\nThread serverThread = new Thread(udpServer,\"UDP_SERVER\");\r\n\r\n// start udp server\r\nserverThread.start();\r\n\r\n```\r\n\r\nUDP client socket will broadcast data to this server : \r\n\r\n```\r\nUdpClient udpClient = new UdpClient(InetAddress.getByName(SERVER_BROADCAST_IP), PORT);\r\n\r\nudpClient.addClientEventListener(new IudpEventListener() {\r\n\r\n    @Override\r\n    public void onDataReceived(byte[] data) {\r\n        System.out\r\n                .println(\"[UDP CLIENT] new data receveived in client : \"\r\n                        + new String(data));\r\n    }\r\n});\r\n```\r\n\r\nTo send a string message use : ``udpClient.sendMessage(String message);`` method : \r\n\r\n```\r\nudpClient.sendMessage(\"HELLO\");\r\n```\r\n\r\nMecanism of event listener is exactly the same as explained before for client socket in Java or for Java websocket lib (http://akinaru.github.io/websocket-java/).\r\n\r\n``onDataReceived(byte[] data)`` for UDP client callback will enable you to get incoming data response from UDP server.\r\n\r\n``onDataReceived(byte[] data, IUdpServer server,InetAddress clientAddress, int clientPort) for UDP server callback will enable you to get incoming data from the client and to redispatch any response you want to this client thanks to ``IUdpServer`` object that permits you to write a ``byte[]`` data like this :\r\n\r\n``\r\nserver.write(\"Hello from websocket server\".getBytes(),clientAddress, clientPort);\r\n``\r\n\r\nWith address and port, UDP server will send your data back to client.\r\n\r\nFor now, I didn't put in place a timer mecanisme on client side, to close client receiving thread. \r\nTODO : timeout for client UDP socket waiting for response\r\n\r\n<hr/>\r\n\r\n<b>Keystore : public and private server certificates</b>\r\n\r\n* To convert cert and key certs to p12 : \r\n\r\n``openssl pkcs12 -export -out server.p12 -inkey server.key -in server.crt``\r\n\r\nThus, you will have : ``String KEYSTORE_DEFAULT_TYPE = \"PKCS12\"``\r\n\r\n* To convert your p12 (containing public and private cert) to jks : \r\n\r\nYou have to know your alias (name matching your cert entry), if you dont have it retrieve it with : ``keytool -v -list -storetype pkcs12 -keystore server.p12``\r\n\r\n``keytool -importkeystore -srckeystore server.p12 -srcstoretype PKCS12 -deststoretype JKS -destkeystore server.jks``\r\n\r\nThus, you will have : ``String KEYSTORE_DEFAULT_TYPE = \"JKS\"``\r\n\r\n<b>Trustore : should contain only CA certificates</b>\r\n\r\nconvert ca cert to jks : \r\n\r\n```keytool -import -alias ca -file ca.crt -keystore cacerts.jks -storepass 123456```\r\n\r\nThus, you will have : ``String TRUSTORE_DEFAULT_TYPE = \"JKS\"``\r\n\r\n<hr/>\r\n\r\n\r\n<b>QT C++ Non Blocking HTTP server socket</b>\r\n\r\nInstantiation and start : \r\n\r\n```\r\nHttpServer server;\r\n\r\nserver.listen(QHostAddress(IP),PORT);\r\n\r\n```\r\n\r\n\r\nYou can add socket event listener that notify you of incominh http request/response \r\n\r\n```\r\nClientSocketHandler *clientHandler = new ClientSocketHandler();\r\n\r\nserver.addClientEventListener(clientHandler);\r\n```\r\n\r\n``ClientSocketHandler`` inherit from interface ``IClientEventListener`` which contains following methods :\r\n* ``void onHttpRequestReceived(IHttpClient &client,Ihttpframe* consumer);`` : notify when http request is received\r\n* ``void onHttpResponseReceived(IHttpClient &client,Ihttpframe* consumer);`` : notify when http response is received\r\n\r\nYou can send http response or http request back to the client with ``IHttpClient`` got from previous callback.\r\n\r\n ``IHttpClient`` has a ``sendHttpMessage(std::string message)`` for sending http message back to client\r\n\r\n<hr/>\r\n<b>TroubleShooting</b>\r\n\r\n<i>Bad certificate | Unknown CA errors</i>\r\n\r\nThis could mean you didn't import your not-trusted-CA certificate into your browser.\r\n\r\n<i>The remote host closed the connection</i>\r\n\r\nUsually happen when your browser closed the connection before the end of SSL handshake. If you already added your CA to your browser dont worry.\r\nBoth Chrome and Firefox need to MANUALLY add the certificate (in a popup) so putting it in parameter menu don't change anything.\r\n\r\nJust load your URL with \"https\" : https://127.0.0.1:8443 . Browser will prompt you to accept the certificates and it will probably solve your connection error.\r\n\r\n<i>CKR_DOMAIN_PARAMS_INVALID error using openjdk</i>\r\n\r\nWith openjdk-6-jdk and openjdk-7-jdk, I encountered java.security bug described in https://bugs.launchpad.net/ubuntu/+source/openjdk-7/+bug/1006776 triggering a ``CKR_DOMAIN_PARAMS_INVALID`` exception error. Solution was to edit java.security parameters in /etc/java-7-openjdk/security/java.security \r\n\r\nI replaced that : \r\n```\r\nsecurity.provider.9=sun.security.smartcardio.SunPCSC\r\nsecurity.provider.10=sun.security.pkcs11.SunPKCS11 ${java.home}/lib/security/nss.cfg\r\n```\r\n\r\nwith that : \r\n```\r\n#security.provider.9=sun.security.smartcardio.SunPCSC\r\nsecurity.provider.9=sun.security.ec.SunEC\r\n#security.provider.10=sun.security.pkcs11.SunPKCS11 ${java.home}/lib/security/nss.cfg\r\n```\r\n\r\n<b>Browser tested</b>\r\n\r\nThis has been tested on following browser : \r\n* Chrome\r\n* Chromium\r\n* Firefox\r\n\r\n<hr/>\r\n\r\n<b>Debugging SSL connection error</b>\r\n\r\nI recommmend using openssl command line tool to debug ssl connection : \r\n\r\n``openssl s_client -connect 127.0.0.1:8443``\r\n\r\nYou can also use vm argument debugging java ssl implementation : ``-Djavax.net.debug=ssl``\r\n\r\n<hr/>\r\n\r\n<b>Server-Client key/cert generation</b>\r\n\r\nCerts are in libwesocket-test/certs folder, you will find server,client and ca cert build with easy-rsa :\r\n\r\nhttps://github.com/OpenVPN/easy-rsa\r\n\r\nWith last release of easy-rsa, you can build your own key with the following : \r\n\r\n* ``./build-ca`` : generate a new CA for you\r\n* ``./build-server-full myServer`` : will build for you public cert and private cert signed with CA for server\r\n* ``./build-client-full myClient`` : will build for you public cert and private cert signed with CA for client\r\n\r\n<b>How to close my HTTP server ?</b>\r\n\r\n``server.closeServer();``\r\n\r\n<hr/>\r\n\r\n<b>COMMAND LINE SYNTAX</b> \r\n\r\nThe following will open http server on port 4343 (default port value for my exemple)\r\n\r\n``java -cp ../libs/http-endec-1.0.jar:libsocket-1.0.jar fr.bmartel.network.LaunchServer``\r\n\r\nYou can change port number by specifying yours\r\n\r\n``java -cp ../libs/http-endec-1.0.jar:libsocket-1.0.jar fr.bmartel.network.LaunchServer 4343``\r\n\r\nThis exemple is launched from /release folder\r\n\r\n<hr/>\r\n\r\n<b>Java HTTP server : Exemple with Browser HTTP client</b>\r\n\r\nThis exemple is located in server/server-socket/blocking/no-ssl/java or server/server-socket/blocking/ssl/java\r\n\r\n* Launch the HTTP server on port 8443\r\n* On your browser go to url http://127.0.0.1:8443/index\r\n\r\n![client side](https://raw.github.com/akinaru/socket-multiplatform/master/clientSide.png)\r\n\r\n\r\n<b>QT C++ non-blocking HTTP server : Exemple with Browser HTTP client</b>\r\n\r\nThis exemple is located in server/server-socket/non-blocking/no-ssl/cpp or server/server-socket/non-blocking/ssl/cpp\r\n\r\n* Launch the HTTP server on port 8443\r\n* On your browser go to url http://127.0.0.1:8443/index\r\n\r\n![client side](https://raw.github.com/akinaru/socket-multiplatform/master/clientSideHttpCpp.png)\r\n\r\n<b>Java HTTP client : Exemple with Java socket server <-> Java socket client</b>\r\n\r\nThis exemple is located in client/socket-client/no-ssl/java or client/socket-client/ssl/java\r\n\r\nLaunch your LaunchClient java exec, it will :\r\n* open a server on 127.0.0.1:8443 (ssl or not)\r\n* build a client socket to be connecte to latter server later\r\n* ask you a set of command which will match HTTP request to be sent to this server. Each command is mapped in the server and a response is sent back to the client.\r\n\r\n![client side](https://raw.github.com/akinaru/socket-multiplatform/master/client_to_server_java.png)\r\n\r\n<hr/>\r\n\r\n<b>Java UDP Server <-> Java UDP client communications</b>\r\n\r\nThis exemple is located in udp/ for the class : fr.bmartel.network.LaunchUdpSocket\r\n=> This will launch one UDP server and one UDP client that connect to this server. UDP Server will send back a response to UDP client\r\n\r\nLike all other socket connections lib, event listeners are used to catch data :\r\n\r\n![udp communication](https://raw.github.com/akinaru/socket-multiplatform/master/udp_client_to_server_java.png)\r\n\r\n<hr/>\r\n\r\n<b>Java</b>\r\n\r\n* Project is JRE 1.7 compliant\r\n* You can build it with ant => build.xml\r\n* Development on Eclipse \r\n\r\n<b>C++ QT</b>\r\n\r\n* Project is Qt4 compliant\r\n* You can build it with qmake\r\n* Development on QtCreator\r\n\r\nTODO : timeout for client UDP socket waiting for response\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}